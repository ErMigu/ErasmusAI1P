1-Conflict-Free Sets (Find sets of arguments where no argument attacks another within the set)
% INPUTS
arg(a). arg(b). arg(c). arg(d). arg(e).
att(a, b). att(b, c). att(c, a). att(d,e).

%GEN SETS
{ in(X) : arg(X) }.

%FOR EVERY X,Y IN THE ARG
:- free(X).
free(X):- att(X,Y), in(X), in(Y).

#show in/1.

//---------------------------------

2-Admissible Sets (Find conflict-free sets where each argument is defended against attackers)
% INPUTS
arg(a). arg(b). arg(c). arg(d). arg(e).
att(a, b). att(b, c). att(c, a). att(d,e).

%GEN SETS
{ in(X) : arg(X) }.

%FOR EVERY X,Y IN THE ARG
:- free(X).
free(X):- att(X,Y), in(X), in(Y).

%EVERY ATT IS DEFENDED BY SOMEONE OF THE SET
:- in(X), att(Y, X), not def(X, Y).
def(X, Y) :- in(Z), att(Z,Y), arg(X).

#show in/1.

//---------------------------------

3-Stable Extensions (Find admissible sets that attack every argument not in the set)
% INPUTS
arg(a). arg(b). arg(c). arg(d). arg(e).
att(a, b). att(b, c). att(c, a). att(d,e).

%GEN SETS
{ in(X) : arg(X) }.

%FOR EVERY X,Y IN THE ARG
:- free(X).
free(X):- att(X,Y), in(X), in(Y).

%EVERY ATT IS DEFENDED BY SOMEONE OF THE SET
:- in(X), att(Y, X), not def(X, Y).
def(X, Y) :- in(Z), att(Z,Y), arg(X).

%ATT ALL ARGUMENTS NOT IN ARE ATT BY SOMEONE IN
:- arg(X), not in(X), not attNS(X).
attNS(X) :- in(Y), att(Y, X).

#show in/1.

//---------------------------------

4-Preferred Extensions (Find maximal admissible sets) MAAAAL
% INPUTS
arg(a). arg(b). arg(c). arg(d). arg(e).
att(a, b). att(b, c). att(c, a). att(d, e).

% GENERATE SETS
{ in(X) : arg(X) }.

% Un argumento X es atacado si hay algún argumento Y en el conjunto tal que Y ataca a X.
att(X) :- in(Y), att(Y, X).

% Un argumento X es defendido si para cada argumento Y que lo ataca, hay algún argumento Z en el conjunto que ataca a Y.
def(X) :- arg(X), not undef(X).
undef(X) :- att(Y, X), not counteratt(Y).
counteratt(Y) :- att(Z, Y), in(Z).

% Un conjunto es un preferred set si cada argumento en el conjunto es defendido.
:- in(X), not def(X).

% Se evita incluir argumentos atacados en el conjunto.
:- in(X), att(X).

% Asegurar que el conjunto no esté vacío.
:- not non_empty_set.
non_empty_set :- in(_).

% Se busca maximizar los argumentos en el conjunto.
#maximize { 1@1, X : in(X) }.

% Mostrar solo las soluciones que nos interesan.
#show in/1.


//---------------------------------